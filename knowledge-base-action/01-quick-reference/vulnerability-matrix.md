# Smart Contract Vulnerability Matrix

Quick reference guide for the 20 most critical smart contract vulnerabilities with prevention strategies and OpenZeppelin solutions.

**Last Updated:** November 15, 2025
**Sources:** kadenzipfel/smart-contract-vulnerabilities, ConsenSys Best Practices, crytic/not-so-smart-contracts

---

## Top 20 Critical Vulnerabilities

| # | Vulnerability | Severity | Description | Prevention | OZ Solution |
|---|--------------|----------|-------------|------------|-------------|
| 1 | **Reentrancy** | CRITICAL | Attacker recursively calls function before state updates complete, draining funds | 1. Checks-Effects-Interactions pattern<br>2. Update state before external calls<br>3. Use reentrancy guard | `ReentrancyGuard` with `nonReentrant` modifier |
| 2 | **Access Control** | CRITICAL | Unauthorized users execute privileged functions due to missing/weak access controls | 1. Use modifiers for all privileged functions<br>2. Implement role-based access<br>3. Never use tx.origin | `Ownable`, `AccessControl`, `Ownable2Step` |
| 3 | **Delegatecall to Untrusted** | CRITICAL | Malicious contract modifies caller's storage via delegatecall | 1. Only delegatecall to trusted contracts<br>2. Whitelist allowed targets<br>3. Validate callee addresses | Use OZ proxy patterns: `ERC1967Proxy`, `UUPSUpgradeable` |
| 4 | **Integer Overflow/Underflow** | HIGH | Arithmetic operations exceed type limits causing unexpected values | 1. Use Solidity >=0.8.0 (built-in checks)<br>2. Use SafeMath for <0.8.0<br>3. Validate input ranges | Built-in Solidity 0.8+, `SafeCast` for conversions |
| 5 | **DoS with Revert** | HIGH | Contract functionality blocked by intentional revert in external call | 1. Use pull-over-push payment pattern<br>2. Avoid unbounded loops<br>3. Handle failed transfers gracefully | `PullPayment` pattern, avoid push payments |
| 6 | **Unchecked Call Return** | HIGH | Failed external call not detected, contract continues with wrong state | 1. Always check return values<br>2. Use require() on calls<br>3. Handle failures explicitly | `SafeERC20` (`safeTransfer`, `safeTransferFrom`) |
| 7 | **Timestamp Dependence** | MEDIUM | Contract logic depends on block.timestamp which miners can manipulate (±15 sec) | 1. Use block.number for ordering<br>2. Allow timestamp tolerance<br>3. Don't use for randomness | No direct solution, use time carefully |
| 8 | **Frontrunning** | MEDIUM | Attacker observes pending transaction and submits their own with higher gas | 1. Use commit-reveal schemes<br>2. Implement transaction ordering protection<br>3. Batch operations | `EIP712` for signed messages, no direct guard |
| 9 | **Insufficient Gas Griefing** | MEDIUM | Caller provides just enough gas to execute but not complete, causing issues | 1. Don't rely on all gas being forwarded<br>2. Validate minimum gas requirements<br>3. Use explicit gas limits | No direct solution, careful gas management |
| 10 | **Floating Pragma** | MEDIUM | Contract compiled with different compiler versions, introducing bugs | 1. Lock pragma to specific version<br>2. Test with exact compiler version<br>3. Document version requirements | N/A - Use `pragma solidity 0.8.20;` |
| 11 | **Default Visibility** | MEDIUM | Functions without explicit visibility allow unintended access | 1. Always specify function visibility<br>2. Default to most restrictive<br>3. Review all public functions | N/A - Compiler enforces in 0.5.0+ |
| 12 | **Signature Replay** | HIGH | Valid signature reused on different chain or contract | 1. Include chain ID in signature<br>2. Use nonces for uniqueness<br>3. Implement EIP-712 | `EIP712`, `Nonces` mixin |
| 13 | **Hash Collision** | MEDIUM | abi.encodePacked() can cause collision with dynamic types | 1. Use abi.encode() instead<br>2. Separate dynamic type parameters<br>3. Add delimiters between inputs | N/A - Use `abi.encode()` |
| 14 | **Arbitrary Storage Write** | CRITICAL | Attacker writes to arbitrary storage slots, corrupting contract state | 1. Validate array indices<br>2. Use safe math for offsets<br>3. Never trust user-controlled indices | No direct solution, careful storage management |
| 15 | **Incorrect Inheritance** | MEDIUM | Wrong order in multiple inheritance causes storage collisions or wrong overrides | 1. Follow C3 linearization rules<br>2. Most specific contracts last<br>3. Test inheritance thoroughly | OZ contracts follow correct patterns |
| 16 | **Assert Violation** | LOW | Assert used incorrectly, consuming all gas instead of refunding | 1. Use require() for input validation<br>2. Use assert() only for invariants<br>3. Prefer custom errors (0.8.4+) | Use `require()` and custom errors |
| 17 | **Oracle Manipulation** | HIGH | Price oracle manipulated via flash loans or low liquidity | 1. Use time-weighted average prices (TWAP)<br>2. Multiple oracle sources<br>3. Validate price reasonableness | N/A - Use Chainlink or similar |
| 18 | **DoS Gas Limit** | MEDIUM | Unbounded loop exceeds block gas limit, making function uncallable | 1. Avoid unbounded loops<br>2. Implement pagination<br>3. Use pull pattern for distributions | Use `EnumerableSet` carefully, pagination |
| 19 | **Lack of Precision** | MEDIUM | Integer division causes rounding errors, loss of funds | 1. Multiply before divide<br>2. Use higher precision intermediates<br>3. Round in user's favor for fairness | `Math` library with rounding modes |
| 20 | **Authorization via tx.origin** | HIGH | tx.origin used for auth allows phishing attacks | 1. Never use tx.origin for authorization<br>2. Always use msg.sender<br>3. Implement proper access control | Use `msg.sender` in all OZ contracts |

---

## Vulnerability Categories

### By Attack Vector

**External Call Vulnerabilities**
- Reentrancy (#1)
- DoS with Revert (#5)
- Unchecked Call Return (#6)
- Insufficient Gas Griefing (#9)

**Access & Authorization**
- Access Control (#2)
- Authorization via tx.origin (#20)
- Signature Replay (#12)

**State Management**
- Arbitrary Storage Write (#14)
- Incorrect Inheritance (#15)
- Delegatecall to Untrusted (#3)

**Economic Attacks**
- Oracle Manipulation (#17)
- Frontrunning (#8)

**Data & Logic**
- Integer Overflow/Underflow (#4)
- Hash Collision (#13)
- Lack of Precision (#19)

**Code Quality**
- Floating Pragma (#10)
- Default Visibility (#11)
- Assert Violation (#16)

**Resource Limits**
- DoS Gas Limit (#18)
- Timestamp Dependence (#7)

---

## Quick Prevention Checklist

### Before Every External Call
- [ ] Apply `nonReentrant` modifier
- [ ] Update all state variables first (Checks-Effects-Interactions)
- [ ] Check return value with `require()`
- [ ] Consider pull-over-push pattern for payments

### For All State-Changing Functions
- [ ] Add access control modifier (`onlyOwner`, `onlyRole`)
- [ ] Validate all inputs with `require()`
- [ ] Use `msg.sender` not `tx.origin`
- [ ] Emit events for off-chain tracking

### Arithmetic Operations
- [ ] Use Solidity 0.8.0+ for automatic overflow checks
- [ ] Use `SafeCast` when downcasting types
- [ ] Multiply before divide to maintain precision
- [ ] Validate division denominators aren't zero

### Token Operations
- [ ] Use `SafeERC20` library for all ERC20 calls
- [ ] Check balances before and after if needed
- [ ] Handle fee-on-transfer tokens appropriately
- [ ] Never assume token calls succeed

### Code Organization
- [ ] Lock pragma to specific version
- [ ] Explicitly declare all function visibility
- [ ] Follow correct inheritance order (most specific last)
- [ ] Document security assumptions

---

## Common Exploit Patterns

### 1. The DAO Attack (Reentrancy)
```solidity
// VULNERABLE
function withdraw() external {
    uint amount = balances[msg.sender];
    (bool success,) = msg.sender.call{value: amount}("");  // ⚠️ External call before state update
    require(success);
    balances[msg.sender] = 0;  // ❌ Too late!
}

// SECURE
function withdraw() external nonReentrant {
    uint amount = balances[msg.sender];
    balances[msg.sender] = 0;  // ✅ State update first
    (bool success,) = msg.sender.call{value: amount}("");
    require(success);
}
```

### 2. Access Control Bypass
```solidity
// VULNERABLE
function setOwner(address newOwner) external {
    owner = newOwner;  // ⚠️ Anyone can call!
}

// SECURE
function transferOwnership(address newOwner) public virtual onlyOwner {
    require(newOwner != address(0));
    _transferOwnership(newOwner);
}
```

### 3. DoS via Revert
```solidity
// VULNERABLE - Push Pattern
function distributeRewards() external {
    for (uint i = 0; i < users.length; i++) {
        users[i].transfer(rewards[i]);  // ⚠️ One failure reverts all
    }
}

// SECURE - Pull Pattern
function claimReward() external {
    uint amount = rewards[msg.sender];
    rewards[msg.sender] = 0;
    payable(msg.sender).transfer(amount);
}
```

---

## OpenZeppelin Security Toolkit

### Essential Imports for Secure Contracts

```solidity
// Access Control
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";

// Reentrancy Protection
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

// Safe Token Operations
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

// Emergency Controls
import "@openzeppelin/contracts/utils/Pausable.sol";

// Type Safety
import "@openzeppelin/contracts/utils/math/SafeCast.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

// Signature Validation
import "@openzeppelin/contracts/utils/cryptography/EIP712.sol";
import "@openzeppelin/contracts/utils/Nonces.sol";
```

### Security Pattern Template

```solidity
pragma solidity 0.8.20;  // ✅ Locked pragma

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

contract SecureVault is AccessControl, ReentrancyGuard, Pausable {
    using SafeERC20 for IERC20;

    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");

    mapping(address => uint256) private balances;

    event Deposit(address indexed user, uint256 amount);
    event Withdrawal(address indexed user, uint256 amount);

    constructor() {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(ADMIN_ROLE, msg.sender);
    }

    // ✅ Access control + Pausable + Reentrancy guard
    function withdraw(uint256 amount)
        external
        nonReentrant
        whenNotPaused
    {
        // 1. CHECKS
        require(balances[msg.sender] >= amount, "Insufficient balance");

        // 2. EFFECTS
        balances[msg.sender] -= amount;
        emit Withdrawal(msg.sender, amount);

        // 3. INTERACTIONS
        (bool success,) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");
    }

    function pause() external onlyRole(ADMIN_ROLE) {
        _pause();
    }

    function unpause() external onlyRole(ADMIN_ROLE) {
        _unpause();
    }
}
```

---

## Severity Definitions

| Severity | Impact | Exploitability | Examples |
|----------|--------|----------------|----------|
| **CRITICAL** | Loss of funds, contract takeover | Easy to exploit | Reentrancy, Access Control, Delegatecall |
| **HIGH** | Significant loss, partial takeover | Moderate effort | Signature Replay, Oracle Manipulation, tx.origin |
| **MEDIUM** | Limited loss, degraded functionality | Requires specific conditions | DoS, Timestamp, Frontrunning |
| **LOW** | Minor issues, edge cases | Rare or difficult | Assert usage, Floating pragma |

---

## Testing for Vulnerabilities

### Essential Security Tests

```solidity
// Test Reentrancy Protection
function testReentrancyAttack() public {
    vm.expectRevert("ReentrancyGuard: reentrant call");
    attacker.attemptReentrancy();
}

// Test Access Control
function testUnauthorizedAccess() public {
    vm.prank(unauthorizedUser);
    vm.expectRevert(
        abi.encodeWithSelector(
            IAccessControl.AccessControlUnauthorizedAccount.selector,
            unauthorizedUser,
            ADMIN_ROLE
        )
    );
    vault.adminFunction();
}

// Test Integer Overflow (should revert in 0.8.0+)
function testOverflowProtection() public {
    vm.expectRevert();
    uint256 max = type(uint256).max;
    max + 1;  // Should revert
}
```

---

## Additional Resources

### Vulnerability Databases
- **SWC Registry**: https://swcregistry.io/
- **Not So Smart Contracts**: https://github.com/crytic/not-so-smart-contracts
- **Reentrancy Attack List**: https://github.com/pcaversaccio/reentrancy-attacks

### Security Tools
- **Slither**: Static analysis tool
- **Mythril**: Security analysis framework
- **Echidna**: Fuzzing tool
- **Foundry**: Testing framework with invariant testing

### Best Practices
- **ConsenSys Best Practices**: https://consensys.github.io/smart-contract-best-practices/
- **OpenZeppelin Docs**: https://docs.openzeppelin.com/contracts/
- **Solidity Security**: https://blog.sigmaprime.io/solidity-security.html

---

**Note:** This matrix should be consulted before every smart contract deployment. Security is not a one-time check but an ongoing process throughout development.
