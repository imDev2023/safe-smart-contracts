# ERC1155 - Multi-Token Standard

## Overview

ERC1155 is an advanced token standard that supports multiple token types (both fungible and non-fungible) in a single contract. It's highly gas-efficient with batch operations.

**Contract Path**: `@openzeppelin/contracts/token/ERC1155/ERC1155.sol`
**Standard**: [EIP-1155](https://eips.ethereum.org/EIPS/eip-1155)

## Key Features

- **Multiple token types** in one contract
- **Batch transfers** for gas efficiency
- **Mixed fungible and non-fungible** tokens
- **Optimal for gaming** and complex ecosystems

## Core Functions

```solidity
function balanceOf(address account, uint256 id) external view returns (uint256)
function balanceOfBatch(address[] accounts, uint256[] ids) external view returns (uint256[])
function setApprovalForAll(address operator, bool approved) external
function isApprovedForAll(address account, address operator) external view returns (bool)
function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes data) external
function safeBatchTransferFrom(address from, address to, uint256[] ids, uint256[] amounts, bytes data) external
```

## Basic Implementation

```solidity
import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";

contract GameItems is ERC1155 {
    uint256 public constant GOLD = 0;
    uint256 public constant SILVER = 1;
    uint256 public constant SWORD = 2;
    uint256 public constant SHIELD = 3;

    constructor() ERC1155("https://game.example/api/item/{id}.json") {
        // Mint fungible tokens
        _mint(msg.sender, GOLD, 10**18, "");    // 1M gold coins
        _mint(msg.sender, SILVER, 10**27, "");  // 1B silver coins

        // Mint non-fungible items
        _mint(msg.sender, SWORD, 1, "");        // 1 unique sword
        _mint(msg.sender, SHIELD, 1, "");       // 1 unique shield
    }

    function mint(address to, uint256 id, uint256 amount) public {
        _mint(to, id, amount, "");
    }

    function mintBatch(address to, uint256[] memory ids, uint256[] memory amounts) public {
        _mintBatch(to, ids, amounts, "");
    }
}
```

## Batch Operations

### Batch Minting
```solidity
uint256[] memory ids = new uint256[](3);
ids[0] = GOLD;
ids[1] = SILVER;
ids[2] = SWORD;

uint256[] memory amounts = new uint256[](3);
amounts[0] = 1000;
amounts[1] = 500;
amounts[2] = 1;

_mintBatch(player, ids, amounts, "");
```

### Batch Transfers
```solidity
// Transfer multiple token types in one transaction
safeBatchTransferFrom(from, to, ids, amounts, "");
```

## Gaming Example

```solidity
contract RPGItems is ERC1155, Ownable {
    // Token IDs
    uint256 public constant GOLD = 0;
    uint256 public constant HEALTH_POTION = 1;
    uint256 public constant MANA_POTION = 2;
    uint256 public constant LEGENDARY_SWORD = 3;

    constructor(address initialOwner)
        ERC1155("https://game.example/api/item/{id}.json")
        Ownable(initialOwner)
    {}

    function awardLoot(address player) external {
        uint256[] memory ids = new uint256[](3);
        uint256[] memory amounts = new uint256[](3);

        ids[0] = GOLD;
        ids[1] = HEALTH_POTION;
        ids[2] = MANA_POTION;

        amounts[0] = 100;   // 100 gold
        amounts[1] = 5;     // 5 health potions
        amounts[2] = 3;     // 3 mana potions

        _mintBatch(player, ids, amounts, "");
    }

    function mintLegendaryItem(address player, uint256 itemId) external onlyOwner {
        _mint(player, itemId, 1, "");
    }

    function usePotion(uint256 potionId) external {
        require(balanceOf(msg.sender, potionId) > 0, "No potions");
        _burn(msg.sender, potionId, 1);
        // Apply potion effect
    }
}
```

## URI Pattern

### Dynamic URI
```solidity
// {id} gets replaced with actual token ID
"https://game.example/api/item/{id}.json"

// Token ID 3 resolves to:
// "https://game.example/api/item/3.json"
```

### Custom URI per Token
```solidity
import "@openzeppelin/contracts/token/ERC1155/extensions/ERC1155URIStorage.sol";

contract CustomURIItems is ERC1155URIStorage {
    function mint(address to, uint256 id, string memory tokenURI) public {
        _mint(to, id, 1, "");
        _setURI(id, tokenURI);
    }
}
```

## Supply Tracking

```solidity
import "@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Supply.sol";

contract SupplyTrackedItems is ERC1155Supply {
    constructor() ERC1155("uri") {}

    function totalSupply(uint256 id) public view returns (uint256) {
        return super.totalSupply(id);
    }

    function exists(uint256 id) public view returns (bool) {
        return super.exists(id);
    }
}
```

## Gas Comparison

### Single Transfers
- ERC20: ~50,000 gas
- ERC721: ~60,000 gas
- ERC1155: ~45,000 gas

### Batch Transfers (10 items)
- ERC20: ~500,000 gas (10 separate transfers)
- ERC721: ~600,000 gas (10 separate transfers)
- ERC1155: ~100,000 gas (1 batch transfer) **5-6x cheaper!**

## Best Practices

1. **Use batch operations** for multiple tokens
2. **Plan token ID scheme** (0-999 fungible, 1000+ non-fungible)
3. **Implement supply tracking** if needed
4. **Set appropriate URI patterns**
5. **Consider using for gaming items**
6. **Combine with access control**

## Summary

- ERC1155 supports multiple token types in one contract
- Highly gas-efficient with batch operations
- Ideal for gaming and complex token ecosystems
- Can handle both fungible and non-fungible tokens
- Perfect for applications needing many token types
