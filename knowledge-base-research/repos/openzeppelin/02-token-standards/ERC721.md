# ERC721 - Non-Fungible Token (NFT) Standard

## Overview

ERC721 defines a standard for non-fungible tokens (NFTs) where each token is unique and not interchangeable. Each token has a unique `tokenId` and can have distinct metadata.

**Contract Path**: `@openzeppelin/contracts/token/ERC721/ERC721.sol`
**Standard**: [EIP-721](https://eips.ethereum.org/EIPS/eip-721)

## Core Functions

```solidity
function balanceOf(address owner) external view returns (uint256 balance)
function ownerOf(uint256 tokenId) external view returns (address owner)
function safeTransferFrom(address from, address to, uint256 tokenId) external
function transferFrom(address from, address to, uint256 tokenId) external
function approve(address to, uint256 tokenId) external
function setApprovalForAll(address operator, bool approved) external
function getApproved(uint256 tokenId) external view returns (address operator)
function isApprovedForAll(address owner, address operator) external view returns (bool)
```

## Basic Implementation

```solidity
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";

contract MyNFT is ERC721 {
    uint256 private _nextTokenId;

    constructor() ERC721("MyNFT", "MNFT") {}

    function mint(address to) public {
        uint256 tokenId = _nextTokenId++;
        _safeMint(to, tokenId);
    }
}
```

## Common Extensions

### 1. URIStorage (Individual Metadata)
```solidity
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";

contract NFTWithMetadata is ERC721URIStorage {
    uint256 private _tokenIds;

    constructor() ERC721("MetadataNFT", "META") {}

    function mint(address to, string memory uri) public returns (uint256) {
        uint256 tokenId = _tokenIds++;
        _safeMint(to, tokenId);
        _setTokenURI(tokenId, uri);
        return tokenId;
    }
}
```

### 2. Enumerable (Token Iteration)
```solidity
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";

contract EnumerableNFT is ERC721Enumerable {
    constructor() ERC721("EnumerableNFT", "ENUM") {}

    // Get all tokens owned by an address
    function tokensOfOwner(address owner) public view returns (uint256[] memory) {
        uint256 tokenCount = balanceOf(owner);
        uint256[] memory tokens = new uint256[](tokenCount);
        for (uint256 i = 0; i < tokenCount; i++) {
            tokens[i] = tokenOfOwnerByIndex(owner, i);
        }
        return tokens;
    }
}
```

### 3. Burnable
```solidity
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol";

contract BurnableNFT is ERC721Burnable {
    constructor() ERC721("BurnableNFT", "BURN") {}

    function mint(address to, uint256 tokenId) public {
        _safeMint(to, tokenId);
    }
}

// Usage: owner or approved can burn
nft.burn(tokenId);
```

### 4. Royalty (ERC2981)
```solidity
import "@openzeppelin/contracts/token/common/ERC2981.sol";

contract RoyaltyNFT is ERC721, ERC2981 {
    constructor() ERC721("RoyaltyNFT", "ROYAL") {
        // 5% royalty to creator
        _setDefaultRoyalty(msg.sender, 500); // 500 = 5%
    }

    function mint(address to, uint256 tokenId) public {
        _safeMint(to, tokenId);
    }

    // Required override
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC721, ERC2981)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}
```

## Complete NFT Collection Example

```solidity
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

contract ArtCollection is ERC721URIStorage, Ownable {
    using Strings for uint256;

    uint256 private _tokenIds;
    uint256 public constant MAX_SUPPLY = 10000;
    uint256 public constant MINT_PRICE = 0.08 ether;
    string public baseURI;

    constructor(address initialOwner)
        ERC721("ArtCollection", "ART")
        Ownable(initialOwner)
    {}

    function setBaseURI(string memory _baseURI) public onlyOwner {
        baseURI = _baseURI;
    }

    function mint() public payable {
        require(_tokenIds < MAX_SUPPLY, "Max supply reached");
        require(msg.value >= MINT_PRICE, "Insufficient payment");

        uint256 tokenId = _tokenIds++;
        _safeMint(msg.sender, tokenId);
    }

    function tokenURI(uint256 tokenId)
        public
        view
        override
        returns (string memory)
    {
        require(ownerOf(tokenId) != address(0), "Token doesn't exist");
        return string(abi.encodePacked(baseURI, tokenId.toString(), ".json"));
    }

    function withdraw() public onlyOwner {
        payable(owner()).transfer(address(this).balance);
    }
}
```

## Metadata Standards

### JSON Metadata Structure
```json
{
  "name": "Art Piece #123",
  "description": "A unique piece of digital art",
  "image": "ipfs://QmHash/123.png",
  "attributes": [
    {
      "trait_type": "Background",
      "value": "Blue"
    },
    {
      "trait_type": "Rarity",
      "value": "Common"
    }
  ]
}
```

### On-Chain Metadata Example
```solidity
import "@openzeppelin/contracts/utils/Base64.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

contract OnChainNFT is ERC721 {
    using Strings for uint256;

    function tokenURI(uint256 tokenId)
        public
        view
        override
        returns (string memory)
    {
        string memory json = Base64.encode(
            bytes(
                string(
                    abi.encodePacked(
                        '{"name": "NFT #',
                        tokenId.toString(),
                        '", "description": "Fully on-chain NFT"}'
                    )
                )
            )
        );

        return string(abi.encodePacked("data:application/json;base64,", json));
    }
}
```

## Best Practices

1. **Use `_safeMint` instead of `_mint`**
   ```solidity
   _safeMint(to, tokenId); // Checks if receiver can handle NFTs
   ```

2. **Implement `tokenURI` for metadata**
3. **Set maximum supply**
4. **Add pause functionality for emergencies**
5. **Use Ownable or AccessControl for admin functions**
6. **Consider gas costs for large collections**
7. **Store images on IPFS, not on-chain (usually)**

## Summary

- ERC721 is the standard for unique, non-fungible tokens
- Each token has a unique `tokenId`
- Use extensions for enumeration, metadata, and royalties
- `_safeMint` is preferred over `_mint`
- Store metadata off-chain (IPFS) or generate on-chain
- Perfect for collectibles, art, gaming items, and unique assets
